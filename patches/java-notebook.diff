diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/JavaEvaluator.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/JavaEvaluator.java
new file mode 100644
index 0000000000..c36b63e33e
--- /dev/null
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/JavaEvaluator.java
@@ -0,0 +1,182 @@
+package org.netbeans.modules.java.lsp.server.protocol;
+
+import jdk.jshell.JShell;
+import jdk.jshell.SnippetEvent;
+import com.google.gson.JsonPrimitive;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.net.URLConnection;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import jdk.jshell.SourceCodeAnalysis;
+import org.netbeans.spi.lsp.CommandProvider;
+import org.openide.util.lookup.ServiceProvider;
+
+@ServiceProvider(service = CommandProvider.class)
+public class JavaEvaluator implements CommandProvider {
+
+    private static final String NBLS_JSHELL_EXEC = "nbls.jshell.execute.cell";    
+    private static final String NBLS_JSHELL_CLOSE = "nbls.jshell.cleanup";
+
+    private static final Set<String> COMMANDS = new HashSet<>(Arrays.asList(NBLS_JSHELL_EXEC, NBLS_JSHELL_CLOSE));
+
+    @Override
+    public Set<String> getCommands() {
+        return COMMANDS;
+    }
+
+    @Override
+    public CompletableFuture<Object> runCommand(String command, List arguments) {
+        if (NBLS_JSHELL_EXEC.equals(command)) {
+            String sourceCode = ((JsonPrimitive) arguments.get(0)).getAsString();
+            // handle null values 
+            String notebookId = arguments.size() > 1
+                    ? ((JsonPrimitive) arguments.get(1)).getAsString()
+                    : "default";
+            String classpath = arguments.size() > 2
+                    ? ((JsonPrimitive) arguments.get(2)).getAsString()
+                    : null;
+            String modulePath = arguments.size() > 3
+                    ? ((JsonPrimitive) arguments.get(3)).getAsString()
+                    : null;
+            String addModules = arguments.size() > 4
+                    ? ((JsonPrimitive) arguments.get(4)).getAsString()
+                    : null;
+            boolean enablePreview = arguments.size() > 5
+                    ? ((JsonPrimitive) arguments.get(5)).getAsBoolean()
+                    : false;
+            return evaluate(sourceCode, notebookId, classpath,modulePath,addModules,enablePreview).thenApply(results -> results);
+        } else if(NBLS_JSHELL_CLOSE.equals(command)){
+            String notebookId = ((JsonPrimitive) arguments.get(0)).getAsString();
+            JshellCache.getInstance().closeJshellById(notebookId);
+            
+            return new CompletableFuture<>();
+        }
+        throw new UnsupportedOperationException("Command not supported: " + command);
+    }
+
+    public CompletableFuture<List<EvalResult>> evaluate(String snippet, String notebookId, String classpath, String modulePath, String addModules, boolean enablePreview) {
+        JShell jshell = JshellCache.getInstance().getOrCreateJShell(notebookId, classpath, modulePath, addModules, enablePreview);// remove class path from here later 
+        // What to dow ith errors in optionas provided 
+        ByteArrayOutputStream outputStream = JshellCache.getInstance().getOutputStreamById(notebookId);
+        ByteArrayOutputStream errorStream = JshellCache.getInstance().getErrorStreamById(notebookId);
+        // Update the jshell environment with the latest class path module path and modules
+        // Issues we have to deal with is what if wrong class path or module path or add modules that generates an error here 
+        // Environment updates fails ??
+        // try executing jshell commands using jshell eval 
+        //jshell.addToClasspath(classpath); // works --- issue keep adding even if not changed use eval for jshell commands -- how to execute jshell commands from jshell api
+        // removing from class path ?? --- add to class path vs set the class path
+        // compiler options vs vm options vs addToClasspath vs eval method to execute jshell commands 
+        // Restart is a good option ?? ---- Reload the extension ?? ---> Prompt the user to restart the kernel 
+        // experiments ??
+        // Easier to manage at frontend ??
+        // Updating ---> get all current snippets and then create a new shell run everything again and go ahead now (Valid snippets ??)
+        // MVP ---> restart thats it 
+        // User input ---> compiler options and the vmOptions
+        // Learn about that how to map
+        List<EvalResult> results = new ArrayList<>();
+        try {
+            String codeLeftToEval = snippet.trim();
+            while (!codeLeftToEval.isEmpty()) {
+                SourceCodeAnalysis.CompletionInfo info = jshell.sourceCodeAnalysis().analyzeCompletion(codeLeftToEval);
+                if (info.completeness().isComplete()) {
+                    for (SnippetEvent event : jshell.eval(info.source())) {
+                        flushStreams(results, outputStream, errorStream);
+
+                        if (event.exception() != null) {
+                            results.add(new EvalResult(event.exception().getMessage(), "text/plain"));
+                        } else if (event.value() != null) {
+                            byte[] valBytes = event.value().getBytes();
+                            results.add(new EvalResult(event.value(), detectMime(valBytes)));
+                        }
+
+                        jshell.diagnostics(event.snippet()).forEach(diag
+                                -> results.add(new EvalResult(diag.getMessage(null), "text/plain"))
+                        );
+
+                        flushStreams(results, outputStream, errorStream);
+                    }
+                    flushStreams(results, outputStream, errorStream);
+                }
+                codeLeftToEval = info.remaining();
+            }
+        } catch (Exception e) {
+            results.add(new EvalResult(("Evaluation error: " + e.getMessage()), "text/plain"));
+        }
+        return CompletableFuture.completedFuture(results);
+    }
+
+    private void flushStreams(List<EvalResult> results, ByteArrayOutputStream out, ByteArrayOutputStream err) {
+        if (out.size() > 0) {
+            if (out.toString().startsWith("$$IMAGE")) {
+                int idx = out.toString().indexOf("{");
+                if (idx != -1) {
+                    EvalResult evalResult = parseBase64AndMimeType(out.toString().substring(idx));
+                    if (evalResult != null) {
+                        results.add(evalResult);
+                    }
+                }
+            } else {
+                results.add(new EvalResult(out.toString(), detectMime(out)));
+            }
+            out.reset();
+        }
+        if (err.size() > 0) {
+            results.add(new EvalResult(err.toString(), detectMime(err)));
+            err.reset();
+        }
+    }
+
+    private String detectMime(byte[] data) {
+        try (ByteArrayInputStream in = new ByteArrayInputStream(data)) {
+            String detected = URLConnection.guessContentTypeFromStream(in);
+            return detected != null ? detected : "text/plain";
+        } catch (IOException ex) {
+            return "application/octet-stream";
+        }
+    }
+
+    private String detectMime(ByteArrayOutputStream data) {
+        return detectMime(data.toByteArray());
+    }
+
+    public static class EvalResult {
+
+        private final String data;
+        private final String mimeType;
+
+        public EvalResult(String rawData, String mimeType) {
+            this.data = rawData;
+            this.mimeType = mimeType;
+        }
+
+        public String getData() {
+            return data;
+        }
+
+        public String getMimeType() {
+            return mimeType;
+        }
+    }
+
+    public static EvalResult parseBase64AndMimeType(String input) {
+        Pattern pattern = Pattern.compile("\\{base64=([^,]+), mimeType=([^}]+)\\}");
+        Matcher matcher = pattern.matcher(input);
+
+        if (matcher.find()) {
+            String base64Content = matcher.group(1);
+            String mimeType = matcher.group(2);
+
+            return new EvalResult(base64Content, mimeType);
+        }
+
+        return null;
+    }
+}
diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/JshellCache.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/JshellCache.java
new file mode 100644
index 0000000000..0dc72f17e9
--- /dev/null
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/JshellCache.java
@@ -0,0 +1,195 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.lsp.server.protocol;
+
+import com.google.gson.JsonPrimitive;
+
+import java.io.ByteArrayOutputStream;
+import java.io.PrintStream;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicReference;
+
+import jdk.jshell.JShell;
+import jdk.jshell.SnippetEvent;
+import jdk.jshell.SourceCodeAnalysis;
+
+import org.eclipse.lsp4j.ConfigurationItem;
+import org.eclipse.lsp4j.ConfigurationParams;
+import org.openide.util.Lookup;
+
+/**
+ * Singleton class for managing JShell instances per notebook.
+ */
+public class JshellCache {
+
+    private static final JshellCache INSTANCE = new JshellCache();
+
+    public static JshellCache getInstance() {
+        return INSTANCE;
+    }
+
+    private final Map<String, JShell> jshellMap = new ConcurrentHashMap<>();
+    private final Map<String, ByteArrayOutputStream> outputStreamMap = new ConcurrentHashMap<>();
+    private final Map<String, ByteArrayOutputStream> errorStreamMap = new ConcurrentHashMap<>();
+
+    private JshellCache() {
+        // private constructor to enforce singleton
+    }
+    private static boolean  checkEmptyString(String input){
+        return (input==null || input.trim().isEmpty());
+    }
+    public JShell getOrCreateJShell(String notebookId, String classpath,String modulePath, String addModules, boolean enablePreview) {
+        return jshellMap.computeIfAbsent(notebookId, (String id) -> {
+            try {
+                ByteArrayOutputStream outStream = new ByteArrayOutputStream();
+                ByteArrayOutputStream errStream = new ByteArrayOutputStream();
+                outputStreamMap.put(id, outStream);
+                errorStreamMap.put(id, errStream);
+
+                PrintStream outPrintStream = new PrintStream(outStream, true);
+                PrintStream errPrintStream = new PrintStream(errStream, true);
+
+                String javaVersion = System.getProperty("java.version");
+
+                String majorVersion = javaVersion.split("\\.")[0];
+//                String javaFxJarsPath = "/Users/atalati/Downloads/javafx-sdk-21.0.7/lib/javafx.controls.jar:/Users/atalati/Downloads/javafx-sdk-21.0.7/lib/javafx.graphics.jar:/Users/atalati/Downloads/javafx-sdk-21.0.7/lib/javafx.base.jar:/Users/atalati/Downloads/javafx-sdk-21.0.7/lib/javafx.swt.jar:/Users/atalati/Downloads/javafx-sdk-21.0.7/lib/javafx.media.jar:/Users/atalati/Downloads/javafx-sdk-21.0.7/lib/javafx.fxml.jar:/Users/atalati/Downloads/javafx-sdk-21.0.7/lib/javafx.web.jar:/Users/atalati/Downloads/javafx-sdk-21.0.7/lib/javafx.swing.jar:/Users/atalati/Downloads/jCharts-0.7.5/jCharts-0.7.5.jar:/Users/atalati/Downloads/jCharts-0.7.5/lib/batik-awt-util.jar:/Users/atalati/Downloads/jCharts-0.7.5/lib/batik-dom.jar:/Users/atalati/Downloads/jCharts-0.7.5/lib/batik-svggen.jar:/Users/atalati/Downloads/jCharts-0.7.5/lib/batik-util.jar:/Users/atalati/Downloads/jCharts-0.7.5/lib/batik-xml.jar";
+                // Read the docs about compiler options and remote vm options 
+                // santize the input a bit and then use it
+                JShell shell;
+                List<String> options = new ArrayList<String>();
+                List<String> VMOptions = new ArrayList<String>();
+                if(!checkEmptyString(classpath)){options.add("--class-path");options.add(classpath);VMOptions.add("--class-path");VMOptions.add(classpath);}
+                if(!checkEmptyString(modulePath)){options.add("--module-path");options.add(modulePath);VMOptions.add("--module-path");VMOptions.add(modulePath);}
+                if(!checkEmptyString(addModules)){options.add("--add-modules");options.add(addModules);VMOptions.add("--add-modules");VMOptions.add(addModules);}
+                if(enablePreview){options.add("--enable-preview");options.add("--source");options.add(majorVersion);VMOptions.add("--enable-preview");}
+                if(!options.isEmpty()){
+                shell = JShell.builder()
+                            .out(outPrintStream)
+                            .err(errPrintStream)
+                            .compilerOptions(options.toArray(new String[options.size()])) // What if the options and VMOptions empty
+                            .remoteVMOptions(VMOptions.toArray(new String[VMOptions.size()]))
+                            .build();
+                }else{
+                shell = JShell.builder()
+                            .out(outPrintStream)
+                            .err(errPrintStream)
+                            .compilerOptions() 
+                            .remoteVMOptions()
+                            .build();
+                }
+
+                
+                // Import common packages
+                List.of("java.io", "java.math", "java.net", "java.nio", "java.nio.file",
+                        "java.text", "java.time", "java.util", "java.util.function",
+                        "java.util.concurrent", "java.util.stream")
+                        .forEach(pkg -> shell.eval("import " + pkg + ".*;\n"));
+
+                // Static imports
+                List.of("java.lang.Math", "java.lang.System", "java.util.stream.Collectors")
+                        .forEach(cls -> shell.eval("import static " + cls + ".*;\n"));
+
+                String codeLeftToEval = initJshellScript;
+                while (!codeLeftToEval.isEmpty()) {
+                    SourceCodeAnalysis.CompletionInfo info = shell.sourceCodeAnalysis().analyzeCompletion(codeLeftToEval);
+                    if (info.completeness().isComplete()) {
+                        for (SnippetEvent event : shell.eval(info.source())) {
+                            if (event.exception() != null) {
+                                System.err.println(event.exception().getMessage());
+                            } else if (event.value() != null) {
+                                System.out.println(event.value());
+                            }
+
+                            shell.diagnostics(event.snippet()).forEach(diag
+                                    -> System.out.println(diag.getMessage(null)));
+
+                        }
+                    }
+                    codeLeftToEval = info.remaining();
+                }
+
+                return shell;
+            } catch (Exception e) {
+                e.printStackTrace();
+                return null;
+            }
+        });
+    }
+
+    public ByteArrayOutputStream getOutputStreamById(String notebookId) {
+        return outputStreamMap.get(notebookId);
+    }
+
+    public ByteArrayOutputStream getErrorStreamById(String notebookId) {
+        return errorStreamMap.get(notebookId);
+    }
+
+    public void closeJshellById(String notebookId) {
+        JShell jshell = jshellMap.remove(notebookId);
+        if (jshell != null) {
+            jshell.close();
+        }
+        outputStreamMap.remove(notebookId);
+        errorStreamMap.remove(notebookId);
+    }
+
+    String initJshellScript = "import java.io.ByteArrayOutputStream;\n"
+            + "import java.io.OutputStream;\n"
+            + "import java.util.Base64;\n"
+            + "import java.util.Map;\n"
+            + "import java.util.HashMap;\n"
+            + "import java.io.InputStream;\n"
+            + "import java.io.ByteArrayInputStream;\n"
+            + "import javax.imageio.ImageIO;\n"
+            + "\n"
+            + "String convertToBase64(ByteArrayOutputStream outStream) {\n"
+            + "    return Base64.getEncoder().encodeToString(outStream.toByteArray());\n"
+            + "}\n"
+            + "\n"
+            + "String detectMimeType(ByteArrayOutputStream outStream) {\n"
+            + "    try {\n"
+            + "        InputStream is = new ByteArrayInputStream(outStream.toByteArray());\n"
+            + "        String formatName = ImageIO.getImageReaders(ImageIO.createImageInputStream(is)).next().getFormatName().toLowerCase();\n"
+            + "        return switch (formatName) {\n"
+            + "            case \"png\" -> \"image/png\";\n"
+            + "            case \"jpeg\", \"jpg\" -> \"image/jpeg\";\n"
+            + "            case \"gif\" -> \"image/gif\";\n"
+            + "            default -> \"application/octet-stream\";\n"
+            + "        };\n"
+            + "    } catch (Exception e) {\n"
+            + "        return \"application/octet-stream\";\n"
+            + "    }\n"
+            + "}\n"
+            + "\n"
+            + "void showAsImage(ByteArrayOutputStream outStream) {\n"
+            + "    Map<String, String> result = new HashMap<>();\n"
+            + "    result.put(\"base64\", convertToBase64(outStream));\n"
+            + "    result.put(\"mimeType\", detectMimeType(outStream));\n"
+            + "    System.out.println(\"$$IMAGE\");\n"
+            + "    System.out.println(result);\n"
+            + "}\n"
+            + "";
+}
